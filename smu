#!/bin/bash
# ARG_OPTIONAL_BOOLEAN([base],[b],[Run base module],[on])
# ARG_OPTIONAL_BOOLEAN([selfupdate],[],[Update set-me-up],[])
# ARG_OPTIONAL_BOOLEAN([provision],[p],[Provision given modules],[off])
# ARG_OPTIONAL_REPEATED([modules],[m],[Modules to provision])
# ARG_OPTIONAL_BOOLEAN([lsrc],[],[List files that will be symlinked via rcm into your home directory],[])
# ARG_HELP([set-me-up installer])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.6.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}

begins_with_short_option()
{
	local first_option all_short_options
	all_short_options='bpmh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_base="on"
_arg_selfupdate="off"
_arg_provision="off"
_arg_modules=()
_arg_lsrc="off"

print_help ()
{
	printf '%s\n' "set-me-up installer"
	printf 'Usage: %s [-b|--(no-)base] [--(no-)selfupdate] [-p|--(no-)provision] [-m|--modules <arg>] [--(no-)lsrc] [-h|--help]\n' "$0"
	printf '\t%s\n' "-b,--base,--no-base: Run base module (on by default)"
	printf '\t%s\n' "--selfupdate,--no-selfupdate: Update set-me-up (off by default)"
	printf '\t%s\n' "-p,--provision,--no-provision: Provision given modules (off by default)"
	printf '\t%s\n' "-m,--modules: Modules to provision (empty by default)"
	printf '\t%s\n' "--lsrc,--no-lsrc: List files that will be symlinked via rcm into your home directory (off by default)"
	printf '\t%s\n' "-h,--help: Prints help"
}

parse_commandline ()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-b|--no-base|--base)
				_arg_base="on"
				test "${1:0:5}" = "--no-" && _arg_base="off"
				;;
			-b*)
				_arg_base="on"
				_next="${_key##-b}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-b" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			--no-selfupdate|--selfupdate)
				_arg_selfupdate="on"
				test "${1:0:5}" = "--no-" && _arg_selfupdate="off"
				;;
			-p|--no-provision|--provision)
				_arg_provision="on"
				test "${1:0:5}" = "--no-" && _arg_provision="off"
				;;
			-p*)
				_arg_provision="on"
				_next="${_key##-p}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-p" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-m|--modules)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_modules+=("$2")
				shift
				;;
			--modules=*)
				_arg_modules+=("${_key##--modules=}")
				;;
			-m*)
				_arg_modules+=("${_key##-m}")
				;;
			--no-lsrc|--lsrc)
				_arg_lsrc="on"
				test "${1:0:5}" = "--no-" && _arg_lsrc="off"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

SMU_HOME_DIR=${SMU_HOME_DIR:-"${HOME}/set-me-up"}

readonly module_path="${HOME}/.modules"

provision_enabled() {
    [[ ${_arg_provision} == "on" ]]
}

export _arg_provision
export -f provision_enabled

provision_module() {
    # source base from installation directory
    # this enables smu to work on first time installations
    if [[ "${module}" == "base" ]]; then
        local -r path="${SMU_HOME_DIR}/.dotfiles/base"
    else
        local -r path="${module_path}/${1}"
    fi

    local -r script="${1}.sh"

    if [[ ! -e "${path}/${script}" ]]; then
        echo "${path}/${script} does not seem to exist, skipping."
        false
        return
    fi

    echo "Running ${path}/${script} module"

    (
        cd "${path}/" &&
        [[ -s ./before.sh ]] && source ./before.sh
        source "./${script}" &&
        [[ -s ./after.sh ]] && source ./after.sh
    )
}

if [[ ${_arg_lsrc} == "on" ]]; then
    export RCRC="${SMU_HOME_DIR}/.dotfiles/rcrc" && lsrc -v -d "${SMU_HOME_DIR}/.dotfiles"

    exit
fi

if [[ ${_arg_selfupdate} == "on" ]]; then
    ${module_path}/install.sh --detect

    ! provision_enabled && exit 0
fi

if ! provision_enabled ; then
    _PRINT_HELP=yes die "Please provide the --provision switch to run set-me-up." 1
    exit 0
fi

read -p "set-me-up may overwrite existing files in your home directory. Are you sure? (y/n) " -n 1;
echo "";
[[ ! $REPLY =~ ^[Yy]$ ]] && exit 0

modules=("${_arg_modules[@]}")

# by default run the base module as early as possible
if [[ ${_arg_base} == "on" ]]; then
    modules=("base" "${modules[@]}")
fi

# check if macosupdate is contained in module list and if so queue it at the beginning
if [[ " ${modules[@]} " =~ " macosupdate " ]]; then
    modules=("macosupdate" "${modules[@]}")
fi

# list of executed modules, so we only one run them once
done=()

# run modules
for module in "${modules[@]}"
do
    if [[ ! " ${done[@]} " =~ " ${module} " ]]; then
        provision_module "${module}"
        done=("${module}" "${done[@]}")
    fi
done

echo "------------------------------"
echo "Completed running set-me-up, restart your computer to ensure all updates take effect."
echo "------------------------------"


# ] <-- needed because of Argbash
